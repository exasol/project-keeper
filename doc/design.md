# Design

## Validators

`dsn~validators~1`

As an interface for the different validations, we created the `Validator` interface. It only contains the `validate` method:

```java
public List<ValidationFinding> validate();
```

The `ValidationFinding` consists of:

* A message
* An optional fix for the violation finding

A fix is a function closure that changes the project so that the fixed finding does not happen again.

We decided on this interface since it allows us to:

* Report errors that can't be fixed automatically
* Report an error and directly provide a fix for it

A problem with this approach is that some validation fixes change a resource such as files. If a validator creates multiple validation findings for the same resource, each fix needs to read and write the file.

Consider, for example, the plugin validator for the pom file. If the pom file validator detects multiple missing plugins, each of these fixes would need to write the file since the fixes are executed by the surrounding code and not in a specific order. To solve this, we used the trick to create a compound finding. So basically one finding with one error message that combines one of all its sub findings. Its fix is a method that runs the fixes of all sub-findings and then writes the pom file.

Covers:

* [`feat~fix-findings~1`](system_requirements.md#fix-findings)

Needs: impl


### Project Keeper Self Update

`dsn~verify-own-version~1`

PK is able to detect its own current installed version, retrieve the latest version available for download, and to validate if the current version is not older than the latest available.

All findings related to detecting and verifying its own version are optional.

Rationale: Releasing a new version of PK should not break automated builds of existing projects using PK.

Covers:

* [`feat~self-update~1`](system_requirements.md#self-update)

Needs: impl, utest, itest

`dsn~self-update~1`

PK performs self-update only for Maven projects.

Rationale: CLI users can use PK by executing a jar file with arbitrary location in the file system.
* This location might be unknown to PK and could be read-only.
* Replacing the jar file should be up to the human user.
* Update of PK CLI variant is simple as it just requires to download the latest jar.
* Scope and effort for update is probably small, as most users will probably use a common jar file for all of their projects instead of having a versioned maven plugin reference for each individual maven project.

Covers:

* [`feat~self-update~1`](system_requirements.md#self-update)

Needs: impl, utest, itest

### Required Files Validator

`dsn~required-files-validator~1`

We decided to add the template as resources and describe them in a Java structure (`FileTemplates`).

Covers:

* [`req~verify-existence-of-files~1`](system_requirements.md#verify-existence-of-files)

Needs: impl, utest, itest

### Deleted Files Validator

`dsn~deleted-files-validator~1`

For configuring the deleted files validator we decided on a Java API. For each deleted file PK developers must specify a reason that will be printed as an error message. By that PK can for example tell that the file was moved.

Covers:

* [`req~verify-non-existence-of-files~1`](system_requirements.md#verify-non-existence-of-files)

Needs: impl, utest, itest

### Pom File Validator

`dsn~pom-file-validator~1`

PK generates a second pom file based on the configuration. This file contains the default plugins and dependencies. This file is not meant to be edited by the user.

PK configures the main pom file of the project to use the generated one as a parent. By that users can add additional configuration and also override the generated template.

This approach has the advantage that it separates autogenerated configuration from user-defined configuration.

If a project needs a parent file, users can specify this parent in the PK config. PK will then use this parent as a parent for the autogenerated pom.

Covers:

* [`req~verify-mvn-plugins~1`](system_requirements.md#verify-maven-plugins)
* [`req~verify-maven-dependencies~1`](system_requirements.md#verify-maven-dependencies)

Needs: impl, utest, itest

#### Alternatives

Until version 2.0.0 we used a different approach:

We had only one pom file that was meant to be edited by the users. PK checked some constrains and could also fix them. For example check if a certain plugin is defined.

This approach failed because a pom file can express the same thing often in multiple ways. For example a plugin's config can be in `configuration/` or in `executions/execution/configuration`. Since we only validated the XML, reflecting this flexibility got too complex.

Another problem was, that in multi maven module projects PK enforced the same plugins in all pom files, which is a lot of duplication. That's also true for the current approach, but there it's in files with generated content only. There duplication is not such a problem.

### Dependency Changes Section in changes_x.x.x.md File Validator

`dsn~dependency-section-in-changes_x.x.x.md-file-validator~1`

The basic approach for this validator is to generate the markdown for the `Dependency Changes` section and then compare the content of the project's file with that generated content. In case they differ the validation fails. The automatic fix of the validation error is to override the section with the generated one.

For this feature we need to generate the list of dependency changes since the last release. We decided to generate this list by comparing the dependencies of the last release with the dependencies of the current release.

For both versions we [read the project's dependencies](#reading-project-dependencies) and create a Java model that we then compare to extract the differences.

For getting the last release we use Git. We detect the previous release by walking through the commits on the current branch in reverse order. If we find a tag that looks like a version number we extract the `pom.xml` file from this commit and analyze its dependencies.

We separated the crawling of the dependencies from the rendering of the table so that we can add different crawlers for other languages or build systems in the future.

Needs: impl, utest, itest

Covers:

* `req~verify-dependency-section-in-changes_x.x.x.md-file~1`

### Changelog.md File Validator

`dsn~verify-changelog-file~1`

For validating the `changelog.md` file we first generate the expected content and then compare the actual file with the expected content.

Covers:

* [`req~verify-changelog-file~1`](system_requirements.md#verify-changelog.md-file)

Needs: impl, utest, itest

### Dependencies.md File Validator

`dsn~dependency.md-file-validator~1`

For validating the `dependencies.md` file we first generate the expected content and then compare the actual file with the expected content.

For generating the content we first [read the project's dependencies](#reading-project-dependencies) and then use the maven API to get the project information. To do so, we again use the maven `ProjectBuilder`. This maven class can fetch a dependency from the maven repository (local or remote) and provide a Java representation of the pom file.

We separated the crawling of the dependency information from the rendering of the files so that we can add support for different languages or build systems in the future.

Covers:

* [`req~verify-dependencies-file~1`](system_requirements.md#verify-dependencies.md-file)

Needs: impl, itest

#### Excluding Implicit Plugins from Dependencies.md

`dsn~dependency.md-file-validator-excludes-implicit-plugins~1`

PK excludes implicit plugins from `dependencies.md`.

Rationale:

Maven implicitly adds plugins like `org.apache.maven.plugins:maven-clean-plugin` due to the Maven lifecycle. The version of these plugins depends on the Maven version. Each plugin version defines its own name and license which is included in `dependencies.md`. That means the content of `dependencies.md` depends on the Maven version, causing build failures when using a different Maven version, see [issue #436](https://github.com/exasol/project-keeper/issues/436).

One workaround is pinning the Maven version using `maven-enforcer-plugin` but this causes problems on developer's machines. That's why we decided to remove these implicit plugins from `dependencies.md`.

Needs: impl, utest, itest

### Readme.md File Validator

`dsn~readme-validator~1`

We decided that the readme validator should not be too strict. That means, that it should not enforce a specific structure but only check that the required parts are somewhere in the file. That also means, that the PK can't automatically fix the findings. By that PK makes sure the the `README.md` contains the required parts, but still leaves users a lot of freedom.

Needs: impl, utest, itest

Covers:

* [`req~verify-readme~1`](system_requirements.md#verify-readme.md-file)

### License File Validator

`dsn~license-file-validator~1`

We decided that the license validator only inserts the current year on creation. Another option would have been to add a year range and also validate that it's always up to date. However, since it's not very likely that these projects require a copyright longer than 50-70 years, we decided adding the creation year is enough. In case it still required one can of course add a date range by hand.

Needs: impl, utest, itest

Covers:

* [`req~verify-license-file~1`](system_requirements.md#verify-license-file)

## Gitignore Validator

`dsn~gitignore-validator~1`

Needs: impl, utest, itest

Covers:

* [`req~verify-gitignore-file~1`](system_requirements.md#verify-gitignore-file)

### Reading Project Dependencies

`dsn~reading-project-dependencies~1`

For reading the project's dependencies we decided to use the maven `ProjectBuilder`. Maven injects this object into the main class of PK maven plugin. In contrast to simply instantiating it, this approach introduces coupling and makes unit tests impossible. For that reason in the future, we might want to move the dependency discovery into a dedicated maven plugin and call it via `mvn exec` command.

Unit testing is not possible since `ProjectBuilder` needs to be injected by maven.

Needs: impl, itest

## Maven Integration

### Maven Verify Goal

`dsn~mvn-verify-goal~1`

This plugin defines a maven goal named `verify` that checks if the project matches the defined structure. The default maven lifecycle phase for this goal is the `package` phase.

Covers:

* [`feat~mvn-integration~1`](system_requirements.md#maven-integration)

Needs: impl, itest

### Maven fix Gaol

`dsn~mvn-fix-goal~1`

This plugin defines a maven goal named `fix` that creates or updates the project files so that they match the required project structure.

Covers:

* [`feat~mvn-integration~1`](system_requirements.md#maven-integration)

Needs: impl, itest

## Configuration

### Modules

`dsn~modules~1`

We decided to group sets of validations into modules. These modules represent typical use cases. For example one module is `maven_central` which contains the validations for publishing to Maven Central Artifact Repository.

Covers:

* [`feat~configuration~1`](system_requirements.md#configuration)

Needs: impl, utest

### Excluding Validation Findings

`dsn~excluding~1`

We added the possibility to exclude validation findings.

We decided for an exclude-mechanism where users provide regular expressions that match the messages to exclude.

That allows users to define all kinds of validation findings. In addition, it does not add coupling between config and possible validations.

Rationale:

* Some projects need a non-default configuration
* It helps trying something out

Covers:

* [`feat~configuration~1`](system_requirements.md#configuration)

Needs: impl, utest, itest

## Golang Support

### Get Project Version

`dsn~golang-project-version~1`

PK reads the project version directly from the configuration file. Only a fixed version is supported.

Rationale:

Golang does not store the version number in project files, e.g. `go.mod`. The version is only defined by a tag of the Git repository.

Covers:

* [`req~golang-project-version~1`](system_requirements.md#get-project-version)

Needs: impl, itest

### Get Licenses of Dependencies

`dsn~golang-dependency-licenses~1`

PK uses the [go-licenses](https://github.com/google/go-licenses/) project for retrieving the licenses of the dependencies.

Rationale:

go-licenses is a simple command line tool that outputs the license name and license URL as CSV. Installing it is easy and creating our own tool is a lot of effort.

Covers:

* [`req~golang-dependency-licenses~1`](system_requirements.md#get-licenses-of-dependencies)

Needs: impl, itest

### Get Changed Dependency
`dsn~golang-changed-dependency~1`

PK parses the `go.mod` file to get the changed dependencies since the last release. PK ignores dependencies marked with an `// indirect` comment.

Rationale:

* The `go.mod` format is simple and easy to parse.
* Using a command like `go list -m -f '{{if not (or .Indirect .Main)}}{{.Path}}{{end}}' all` would require checking out the complete sources of the last release tag. The `go.mod` file is not enough to run this command.
* Adding indirect depndencies to the changes list would make it hard to read, because this list can become very long.
* It is a convention in Go projects to mark indirect dependencies with an `// indirect` comment. The `go mod tidy` enforces this automatically.

Covers:

* [`req~golang-changed-dependency~1`](system_requirements.md#get-changed-dependency)

Needs: impl, utest, itest

## NPM Support

### Get Project Version
`dsn~npm-project-version~1`

PK reads the project version from file `package.json`.

Covers:
* [`req~npm-project-version~1`](system_requirements.md#get-project-version)

Needs: impl, itest

### Get Additional Information About Dependencies
`dsn~npm-dependency-additional-information~1`

PK uses the command `npm list` for retrieving additional information of the dependencies such as the URL for obtaining the artifacts of the dependency.

Covers:
* [`req~npm-dependency-additional-information~1`](system_requirements.md#get-additional-information-for-each-dependency)

Needs: impl, utest, itest

### Get Licenses of Dependencies
`dsn~npm-dependency-licenses~1`

PK uses the NPM `license-checker` for retrieving the licenses of the dependencies.

Rationale:

NPM `license-checker` is a simple command line tool that outputs the license name and license URL as Json. Using `npx` enables to use the `license-checker` even without installation.

Covers:
* [`req~npm-dependency-licenses~1`](system_requirements.md#get-licenses-of-dependencies)

Needs: impl, utest, itest

### Get Changed Dependency
`dsn~npm-changed-dependency~1`

PK parses file the `package.json` to get the changed dependencies since the last release.

Covers:
* [`req~npm-changed-dependency~1`](system_requirements.md#get-changed-dependency)

Needs: impl, utest, itest
